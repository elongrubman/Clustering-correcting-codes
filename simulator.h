//
// Created by Â Elon Grubman on 21/01/2020.
//

#ifndef CLUSTERING_CORRECTING_CODES_SIMULATOR_H
#define CLUSTERING_CORRECTING_CODES_SIMULATOR_H

#include "encoded_strand_binary.h"

class simulator;

/*!
 * function who generate vector with error regarding to encoded_data vector
 * @param encoded_data - the vector that the function generated by him
 * @param encoded_data_with_errors - the vector with the generated errors
 * @param number_of_errors - the number of errors that we confirm to do
 */
void makeErrors(vector<int>& encoded_data, vector<int>& encoded_data_with_errors, int number_of_errors){
    unordered_map<int,int> indexes;
    while (number_of_errors > 0){
        int num = (rand() % encoded_data.size());
        auto it = indexes.find(num);
        if(it == indexes.end()){
            indexes[num] = 1;
            number_of_errors--;
        }
    }
    for (auto i = 0; i < encoded_data.size() ; ++i) {
        auto it = indexes.find(i);
        if(it != indexes.end()){
            if(encoded_data[i]==1) encoded_data_with_errors.push_back(0);
            else encoded_data_with_errors.push_back(1);
        }
        else{
            encoded_data_with_errors.push_back(encoded_data[i]);
        }
    }
}

/*!
 * function who get vector<int> and duplicate it between 100-10000 times with error into map.
 * @param map - hash table with int as Key and vector<encoded_strand_binary> as Value.
 * @param i - key to insert for.
 * @param encoded_data - vector<int>.
 * @param as - kind of system assumption.
 * @param e - the distance constraint of the indexes.
 * @param t - the distance constraint of the data of the strands.
 */
void duplicateStrandEndInsertToMap(simulator* simulator, int e, int t, unordered_map<int, vector<encoded_strand_binary>>& map, int i, vector<int>& encoded_data, string as){
    int number_of_duplicates = 100 + (rand()%9900);
    if (as != "D" && as != "NON"){
        simulator.tao = e;
        simulator.ro = (t + 1)/4;
        int delta = number_of_duplicates*(2/3) - number_of_duplicates/2;
        int number_of_good_duplicates =  number_of_duplicates/2 + (rand() % delta);
        bool same_cluster = true;
        bool different_cluster = false;
        vector<encoded_strand_binary> encoded_data_duplications;
        for (int j = 0; j < number_of_good_duplicates; ++j) {
            vector<int> encoded_data_with_errors;
            int number_of_errors = (rand() % (2*simulator->getRo()));
            makeErrors(encoded_data, encoded_data_with_errors, number_of_errors);
            encoded_data_duplications.push_back(encoded_data_with_errors);
        }
        int number_of_bad_duplicates = number_of_duplicates - number_of_good_duplicates;
        for (int k = 0; k < number_of_bad_duplicates; ++k) {
            vector<int> encoded_data_with_errors;
            int number_of_errors = (2*simulator->getRo()) + (rand() % encoded_data.size());
            makeErrors(encoded_data, encoded_data_with_errors, number_of_errors);
            encoded_data_duplications.push_back(encoded_data_with_errors);
        }
        ///shuffle the encoded_data_duplications vector order
        random_device rd;
        mt19937 g(rd());
        shuffle(encoded_data_duplications.begin(), encoded_data_duplications.end(), g);

        ///insert encoded_data duplications to map
        simulator->getMap()[i] = encoded_data_duplications;
    }
    else if(as == "D"){
        simulator.tao = e/2;
        simulator.ro = (t + 1)/4;
    }
    else{
        simulator.tao = e/4;
        simulator.ro = (t + 1)/4;
    }
}

class simulator {
    unordered_map<int, vector<encoded_strand_binary>> map;
    string assumption;
    int tao;
    int ro;

public:
    simulator(int e, int t, unordered_map<int,encoded_strand_binary>& _map, string _assumption) : assumption(std::move(_assumption)){
        long encoded_strands_map_size = _map.size();
        for (int i = 0; i < encoded_strands_map_size; ++i) {
            auto it = _map.find(i);
            if(it == _map.end()){
                cout << "the system can't find the key " << i << " in map" << endl;
            }
            else{
                vector<int> encoded_data = it->second.get_encoded_data();
                duplicateStrandEndInsertToMap(this, e, t, map, i, encoded_data, assumption);
            }
        }
    }

    unordered_map<int, &getMap()  {
        return map;
    }

    void setMap(const unordered_map<int, &map) {
        this->map = map;
    }

    string &getAssumption()  {
        return assumption;
    }

    int getTao()  {
        return tao;
    }

    void setTao(int tao) {
        this->tao = tao;
    }

    int getRo()  {
        return ro;
    }

    void setRo(int ro) {
        this->ro = ro;
    }
};


#endif //CLUSTERING_CORRECTING_CODES_SIMULATOR_H
